/*\n * dht22.c\n * Minimal DHT22 driver for STM32 HAL.\n *\n * Returns 0 on success, -1 on error.\n *\n * IMPORTANT:\n * - Configure the DHT pin in CubeMX (we use PA0 by default).\n * - Ensure InitDWT() is called once before using dht22_read() so delay_us works.\n */\n\n#include "dht22.h"\n#include "main.h" /* for HAL_GPIO_ReadPin / HAL_GPIO_WritePin and DHT pin defs */\n#include "stm32f4xx_hal.h"\n#include <string.h>\n\n/* Edit these to match your board wiring if different */\n#ifndef DHT_PORT\n#define DHT_PORT GPIOA\n#endif\n#ifndef DHT_PIN\n#define DHT_PIN GPIO_PIN_0\n#endif\n\n/* Prototype for delay in microseconds - implemented in main (InitDWT + delay_us) */\nextern void delay_us(uint32_t us);\n\n/* Helper to switch GPIO mode: output push-pull or input floating */\nstatic void dht_set_output(void) {\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\n  GPIO_InitStruct.Pin = DHT_PIN;\n  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n  HAL_GPIO_DeInit(DHT_PORT, DHT_PIN);\n  HAL_GPIO_Init(DHT_PORT, &GPIO_InitStruct);\n}\n\nstatic void dht_set_input(void) {\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\n  GPIO_InitStruct.Pin = DHT_PIN;\n  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  HAL_GPIO_DeInit(DHT_PORT, DHT_PIN);\n  HAL_GPIO_Init(DHT_PORT, &GPIO_InitStruct);\n}\n\nint dht22_read(float *temperature_c, float *humidity_pct) {\n  uint8_t data[5] = {0};\n  uint32_t t;\n  int i, j;\n\n  /* Start signal: pull low for >= 1 ms (we use 1.2 ms) */\n  dht_set_output();\n  HAL_GPIO_WritePin(DHT_PORT, DHT_PIN, GPIO_PIN_RESET);\n  delay_us(1200);\n\n  /* Pull high and switch to input */\n  HAL_GPIO_WritePin(DHT_PORT, DHT_PIN, GPIO_PIN_SET);\n  delay_us(30);\n  dht_set_input();\n\n  /* Wait for sensor response (low ~80us) */\n  t = 0;\n  while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN) == GPIO_PIN_SET) {\n    delay_us(1);\n    if (++t >= 1000) return -1;\n  }\n  /* Wait for sensor's high (~80us) */\n  t = 0;\n  while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN) == GPIO_PIN_RESET) {\n    delay_us(1);\n    if (++t >= 1000) return -1;\n  }\n  /* Wait for first data low */\n  t = 0;\n  while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN) == GPIO_PIN_SET) {\n    delay_us(1);\n    if (++t >= 1000) return -1;\n  }\n\n  /* Read 40 bits */\n  for (i = 0; i < 40; ++i) {\n    /* wait for low (50us) */\n    t = 0;\n    while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN) == GPIO_PIN_RESET) {\n      delay_us(1);\n      if (++t > 1000) return -1;\n    }\n    /* measure length of the following high */\n    uint32_t len = 0;\n    while (HAL_GPIO_ReadPin(DHT_PORT, DHT_PIN) == GPIO_PIN_SET) {\n      delay_us(1);\n      len++;\n      if (len > 200) break;\n    }\n    data[i / 8] <<= 1;\n    /* threshold: > ~40us high means '1' */\n    if (len > 40) data[i / 8] |= 1;\n  }\n\n  /* Restore pin to output-high idle */\n  dht_set_output();\n  HAL_GPIO_WritePin(DHT_PORT, DHT_PIN, GPIO_PIN_SET);\n\n  uint8_t checksum = data[0] + data[1] + data[2] + data[3];\n  if (checksum != data[4]) return -1;\n\n  uint16_t rawH = (data[0] << 8) | data[1];\n  uint16_t rawT = (data[2] << 8) | data[3];\n\n  *humidity_pct = rawH / 10.0f;\n  if (rawT & 0x8000) {\n    rawT &= 0x7FFF;\n    *temperature_c = - (rawT / 10.0f);\n  } else {\n    *temperature_c = rawT / 10.0f;\n  }\n\n  return 0;\n}\n